cor. 		4,290,000,000
sugg.		2,000,000,0
blend.		2,000,000,0
totality.	1,000,00
ratting.	10000,00
pos.		1000
///

cm_wid=0;
cm_grp=1;
while(cm_grp>cm_wid)
{
	generate_group();
	new_cm_wid = main_search(grpAr, len);
	if(r>cm_wid) cm_wid=new_cm_wid;
}

////////////////////////////////////////////
////////////////////////////////////////////
////////////////////////////////////////////////

connection or thread or S-Query properties
min_cor
min_msw
min_cor_msw//two bytes
//......
max_cor
max_msw
max_cor_msw// two bytes.

////////////////////////
Blender*** mat = malloc()
mat_lenAr
mat_sizeAr
mat_rows_len
Blender** sel_pos_objAr = malloc(n_rows*sizeof(Blender));
db->db_flgAr;



me->db_wid_buf
me->db_wid_len


////////////////////////////////////////////////////
////////////////////////////////////////////////////
////********Thread*************/////////////////////
Resetting after one db_ad search

mat_len(it is automaticly set, so no need to be reset.)

Locator* ob = my->pblender;
//me->cl_widAr[wind] = storageAr[m];// completed.
Locator* ob = my->pblender;
my->wid_marks
my->n_total-my->msw_quality
my->cp_marks = ad->ratting_marks;
if(cp_marks<pp_marks && cp_marks>np_marks)
realloc(mat[i], sizeof(Blender*)*MATRIX_DEFAULT_COLUMNS);
MATRIX_DEFAULT_ROWS





mat_handlermat_handler(mat, n_rows);
//if(cp_lowest_marks > rem_marks)	break;// cp_lowest_marks must be uint.../unsigned int/long/char
//next/previous page marks must be converted to positive otherwise the server could be hacked. cp_lowest_marks replaced by smallest->node->marks
commming marks from page with expected new page.

////////////////////////////////////////////////////
////////////////////////////////////////////////////
////********Global*************/////////////////////
global.marks_ar[BLEND_MARKS];
global.marks_ar[COR_WORD_MARKS]
SUG_MSW_QUALITY_MARKS];//4 Miss Spelled Quality.
COR_BLEND_MARKS];
COR_INDEX_MARKS;
[COR_UNIQUENESS_MARKS]
global.marks_ar[SUG_UNIQUENESS_MARKS]
marks = global.marks_ar[SUG_BLEND_MARKS];
marks += global.marks_ar[SUG_INDEX_MARKS];

///////////////////////////////////
///////////////////////////////////
////////////////COMMON///////////////
my->op_mode
////////////////////////////

REF_COUNT_T ref_count;//how much pointers point to mcsq in mcwc.
SCHLIMIL_T char* str;
WCHLIMIL_T char* str;
MARKS_T




////////////////////////////////
////////////////////////////////////////////
////////////////////////////////////////////
1->wid.			20000		WID_MARKS.
2->blend		5000		WID_BLEND_MARKS.

3->sug.			5000		SUG_MARKS.
4->blend.		15000		SUG_BLEND_MARKS.
///////////////////////////////////////////////
5->spell_pos.	50			SUG_REC_POS_MARKS.
6->ratting.		1000		RATTING_MARKS.
7->cmw.			1000/n_cmw	SPELL_ACCURACY_MARKS.//__ This is not a good idea.
8->wpos.		50			WID_POS_MARKS.
//////////////////////////////////////////////
//////////////////////////////////////////////
cache, duplication of wids,  correct-miss_spelled_wid
p
comb_r - val.
corAr  - val.


c -= c_not_found;
r -= r_not_found;
900*3
600*5// total suggs are 6.//

12


//...................

Struct Thread
{
	//Address Info
	
	
	
	
	//*************
	
	//Dic Info
	
	
	//************
	
	
	
	//Common Info
	WIDSIZE_T* widAr;
	
}

typedef Struct Thread Thread;
Thread me;



a b, c d, e f
b a, d c, g h
expec value 

b a, d c, e

p 20, 40, 600
////////////////////////////////////////////////////
msw_indAr[my->n_sugg_ars++] = //_ in dic_query_handler.c




